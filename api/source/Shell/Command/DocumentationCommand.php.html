<html>
    <head>
        <script
            type="text/javascript"
            src="../../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php
namespace Strata\Shell\Command;

use Strata\Shell\Command\StrataCommand;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputDefinition;
use Symfony\Component\Console\Output\OutputInterface;

/**
 * Automates Strata's Documentation.
 *
 * Intended use:
 *     &lt;code&gt;bin/strata document&lt;/code&gt;
 */
class DocumentationCommand extends StrataCommand
{
    /**
     * {@inheritdoc}
     */
    protected function configure()
    {
        $this
            -&gt;setName('document')
            -&gt;setDescription('Documents the current app')
            -&gt;setDefinition(
                new InputDefinition(array(
                    new InputOption('destination', 'c', InputOption::VALUE_OPTIONAL),
                ))
            );
    }

    /**
     * {@inheritdoc}
     */
    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $this-&gt;startup($input, $output);

        $this-&gt;_deletePrevious();

        $this-&gt;_generateAPI();
        $this-&gt;nl();

        $this-&gt;_generateThemesApi();
        $this-&gt;nl();

        $this-&gt;_generateThemesDocumentation();
        $this-&gt;nl();

        $this-&gt;_summary();
        $this-&gt;nl();

        $this-&gt;shutdown();
    }

    /**
     * Gets the documentation's destination, either from an
     * argument passed as option or from the default path.
     * @return string Destination path.
     */
    protected function _getDestination()
    {
        if (!is_null($this-&gt;input-&gt;getOption('destination'))) {
            return $this-&gt;input-&gt;getOption('destination');
        }

        return implode(DIRECTORY_SEPARATOR, array(\Strata\Strata::getRootPath(), &quot;doc&quot;, DIRECTORY_SEPARATOR));
    }

    /**
     * Gets the api documentation's destination
     * @return string Destination path.
     */
    protected function _getApiDestination()
    {
        return $this-&gt;_getDestination() . 'api';
    }

    /**
     * Gets the Wordpress themes documentation's destination
     * @return string Destination path.
     */
    protected function _getWpdocDestination()
    {
        return $this-&gt;_getDestination() . 'wpdoc';
    }

    /**
     * Gets the Wordpress themes API documentation's destination
     * @return string Destination path.
     */
    protected function _getWpApiDestination()
    {
        return $this-&gt;_getDestination() . 'wpapi';
    }

    /**
     * Return the path to the phpDocumentor binary
     * @return string phpDocumentor binary path
     */
    protected function _getPhpDocumentorBin()
    {
        return implode(DIRECTORY_SEPARATOR, array(\Strata\Strata::getVendorPath(), &quot;bin&quot;, &quot;phpDocumentor&quot;));
    }

    /**
     * Outputs a summary of the operation.
     * @return null
     */
    protected function _summary()
    {
        $this-&gt;output-&gt;writeLn(&quot;The project documentation has been generated at the following URLs: &quot;);
        $this-&gt;nl();

        $destination = $this-&gt;_getDestination();
        $this-&gt;output-&gt;writeLn(&quot;&lt;info&gt;API               :&lt;/info&gt; &quot;. $this-&gt;_getApiDestination()   .&quot;/index.html&quot;);
        $this-&gt;output-&gt;writeLn(&quot;&lt;info&gt;Theme API         :&lt;/info&gt; &quot;. $this-&gt;_getWpApiDestination()   .&quot;/index.html&quot;);
        $this-&gt;output-&gt;writeLn(&quot;&lt;info&gt;Theme Information :&lt;/info&gt; &quot;. $this-&gt;_getWpdocDestination() .&quot;/index.html&quot;);
    }

    /**
     * Deletes the previous generated output in the destination folders.
     * @return [type] [description]
     */
    protected function _deletePrevious()
    {
        $this-&gt;_rrmdir($this-&gt;_getApiDestination());
        $this-&gt;_rrmdir($this-&gt;_getWpApiDestination());
        $this-&gt;_rrmdir($this-&gt;_getWpdocDestination());
    }

    /**
     * Generates the API documentation contents
     * @return null
     */
    protected function _generateAPI()
    {
        $srcPath = \Strata\Strata::getSRCPath();

        $this-&gt;output-&gt;writeLn(&quot;&lt;info&gt;Generating API&lt;/info&gt;&quot;);
        $this-&gt;output-&gt;writeLn($this-&gt;tree(true) . &quot;Scanning $srcPath&quot;);
        $this-&gt;nl();

        system(sprintf(&quot;%s -d %s -t %s&quot;, $this-&gt;_getPhpDocumentorBin(), $srcPath, $this-&gt;_getApiDestination()));
    }

    /**
     * Generates the API documentation contents
     * @return null
     */
    protected function _generateThemesAPI()
    {
        $themesPath = \Strata\Strata::getThemesPath();

        $this-&gt;output-&gt;writeLn(&quot;&lt;info&gt;Generating Wordpress theme API&lt;/info&gt;&quot;);
        $this-&gt;output-&gt;writeLn($this-&gt;tree(true) . &quot;Scanning $themesPath&quot;);
        $this-&gt;nl();

        system(sprintf(&quot;%s -d %s -t %s&quot;, $this-&gt;_getPhpDocumentorBin(), $themesPath, $this-&gt;_getWpApiDestination()));
    }


    /**
     * Generates the Wordpress themes documentation contents
     * @return null
     */
    protected function _generateThemesDocumentation()
    {
        $this-&gt;output-&gt;writeLn(&quot;&lt;info&gt;Generating Wordpress theme documentation&lt;/info&gt;&quot;);

        $themesPath = \Strata\Strata::getThemesPath();
        $info = $this-&gt;_scanThemeDirectories($themesPath);
        $this-&gt;_writeThemesDocumentation($info);
    }

    /**
     * Render the theme documentation file based on known $info fields.
     * @todo  This will do for now, but the template shouldn't be hardcoded.
     * @param  array $info The parsed theme data
     * @return bool       True is the file was successfully created.
     */
    protected function _writeThemesDocumentation($info)
    {
        $header = '&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;Overview&lt;/title&gt;';
        $header .= '&lt;link rel=&quot;stylesheet&quot; href=&quot;../api/resources/style.css&quot;&gt;';
        $header .= '&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;content&quot;&gt;';
        $content = '&lt;h1&gt;Project snapshot&lt;/h1&gt;';
        $footer = '&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;';
        $htmlTpl = &quot;&lt;tr&gt;&lt;td class=\&quot;attributes\&quot;&gt;&lt;strong&gt;%s&lt;/strong&gt;&lt;/td&gt;&lt;td class=\&quot;name\&quot;&gt;&lt;div&gt;&lt;code&gt;%s&lt;/code&gt;&lt;div class=\&quot;description short\&quot;&gt;%s&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;

        foreach ($info[&quot;themes&quot;] as $themeName =&gt; $theme) {
            $content .= &quot;&lt;h2&gt;$themeName&lt;/h2&gt;&quot;;
            $content .= '&lt;table class=&quot;summary&quot; id=&quot;templates&quot; style=&quot;width:45%; float:left;&quot;&gt;';
            $content .= &quot;&lt;caption&gt;This theme defines &quot; . count($theme[&quot;templates&quot;]) . &quot; template files.&lt;/caption&gt;&lt;tbody&gt;&quot;;

            foreach ($theme[&quot;templates&quot;] as $template) {
                $content .= sprintf($htmlTpl,
                        empty($template[&quot;Template Name&quot;]) ? 'Name not specified' : $template[&quot;Template Name&quot;],
                        $template[&quot;filename&quot;],
                        empty($template[&quot;Description&quot;]) ? 'Missing description.' : $template[&quot;Description&quot;]
                );
            }
            $content .= &quot;&lt;/tbody&gt;&lt;/table&gt;&quot;;

            $content .= '&lt;table class=&quot;summary&quot; id=&quot;libs&quot; style=&quot;width:45%; margin-left:2%; float:left;&quot;&gt;';
            $content .= &quot;&lt;caption&gt;This theme uses &quot; . count($theme[&quot;libs&quot;]) . &quot; obvious library files.&lt;/caption&gt;&lt;tbody&gt;&quot;;
            foreach ($theme[&quot;libs&quot;] as $lib) {
                $content .= sprintf($htmlTpl,
                        empty($lib[&quot;Name&quot;]) ? 'Name not specified' : $lib[&quot;Name&quot;],
                        $lib[&quot;filename&quot;],
                        empty($lib[&quot;Description&quot;]) ? 'Missing description.' : $lib[&quot;Description&quot;]
                );
            }
            $content .= &quot;&lt;/tbody&gt;&lt;/table&gt;&quot;;
        }

        $wpdocdir = $this-&gt;_getWpdocDestination();
        if (!is_dir($wpdocdir)) {
            mkdir($wpdocdir);
        }

        return file_put_contents($wpdocdir . &quot;/index.html&quot;, $header . $content . $footer, LOCK_EX);
    }

    /**
     * Scans the theme directories of the current Wordpress installation and looks
     * for things useful for a programmer.
     * @param  string $base The base theme path.
     * @return array       A associative array of theme information
     */
    protected function _scanThemeDirectories($base)
    {
        $tree = array(&quot;themes&quot; =&gt; array());

        $di = new \RecursiveDirectoryIterator($base);
        foreach (new \RecursiveIteratorIterator($di) as $filename =&gt; $file) {
            // Obtain the theme scope, add it to the stack if it wasn't
            // saved yet.
            $theme = null;
            if (preg_match(&quot;/themes\/(.+?)\//&quot;, $filename, $matches)) {
                $theme = $matches[1];
                if (!array_key_exists($theme, $tree[&quot;themes&quot;])) {
                    $tree[&quot;themes&quot;][$theme] = array(
                        &quot;templates&quot; =&gt; array(),
                        &quot;libs&quot;      =&gt; array()
                    );

                    $this-&gt;output-&gt;writeLn($this-&gt;tree(true) . &quot;Scanning $theme&quot;);
                }
            }

            // Match for wordpress templates
            if (preg_match(&quot;/themes\/$theme\/template\-(.+?)\.php/&quot;, $filename, $matches)) {
                $template = $matches[1];
                if (!array_key_exists($template, $tree[&quot;themes&quot;][$theme][&quot;templates&quot;])) {
                    $tree[&quot;themes&quot;][$theme][&quot;templates&quot;][$template] = array();

                    $headerKeys = array(&quot;Template Name&quot; =&gt; &quot;Template Name&quot;, &quot;Description&quot; =&gt; &quot;Description&quot;);
                    $templateDetails = $this-&gt;_getFileData($filename, $headerKeys);

                    $tree[&quot;themes&quot;][$theme][&quot;templates&quot;][$template][&quot;filename&quot;] = $filename;
                    foreach ($headerKeys as $key) {
                        $tree[&quot;themes&quot;][$theme][&quot;templates&quot;][$template][$key] = $templateDetails[$key];
                    }
                }
            }

            // Match for custom lib files
            if (preg_match(&quot;/themes\/$theme\/lib\/(.+?)\.php/&quot;, $filename, $matches)) {
                $lib = $matches[1];

                if (!array_key_exists($lib, $tree[&quot;themes&quot;][$theme][&quot;libs&quot;])) {
                    $tree[&quot;themes&quot;][$theme][&quot;libs&quot;][$lib] = array();

                    $headerKeys = array(&quot;Name&quot; =&gt; &quot;Name&quot;, &quot;Description&quot; =&gt; &quot;Description&quot;);
                    $libDetails = $this-&gt;_getFileData($filename, $headerKeys);

                    $tree[&quot;themes&quot;][$theme][&quot;libs&quot;][$lib][&quot;filename&quot;] = $filename;
                    foreach ($headerKeys as $key) {
                        $tree[&quot;themes&quot;][$theme][&quot;libs&quot;][$lib][$key] = $libDetails[$key];
                    }
                }
            }
        }

        return $tree;
    }

    /**
     * This is a lightly modified copy of Wordpress get_file_data() found in wp-includes/functions.php.
     * Because we don't load Wordpress when executing Strata Shell, we don't have access to it.
     * @todo  Allow a way for Strata to load Wordpress on demand.
     * @param  [type] $file            [description]
     * @param  [type] $default_headers [description]
     * @param  string $context         [description]
     * @return [type]                  [description]
     */
    protected function _getFileData($file, $all_headers = array(), $context = '')
    {
        // We don't need to write to the file, so just open for reading.
        $fp = fopen( $file, 'r' );

        // Pull only the first 8kiB of the file in.
        $file_data = fread( $fp, 8192 );

        // PHP will close file handle, but we are good citizens.
        fclose( $fp );

        // Make sure we catch CR-only line endings.
        $file_data = str_replace( &quot;\r&quot;, &quot;\n&quot;, $file_data );

        /**
         * Filter extra file headers by context.
         *
         * The dynamic portion of the hook name, `$context`, refers to
         * the context where extra headers might be loaded.
         *
         * @since 2.9.0
         *
         * @param array $extra_context_headers Empty array by default.
         */

        foreach ( $all_headers as $field =&gt; $regex ) {
            if ( preg_match( '/^[ \t\/*#@]*' . preg_quote( $regex, '/' ) . ':(.*)$/mi', $file_data, $match ) &amp;&amp; $match[1] )
                $all_headers[ $field ] = $match[1];
            else
                $all_headers[ $field ] = '';
        }

        return $all_headers;

    }

    /**
     * Recurses through a directory and deletes sub-directories.
     * @param  string $dir A directory path to delete
     * @return null
     */
    protected function _rrmdir($dir)
    {
        if (is_dir($dir)) {
            $objects = scandir($dir);
            foreach ($objects as $object) {
                if ($object != &quot;.&quot; &amp;&amp; $object != &quot;..&quot;) {
                    if (filetype($dir.&quot;/&quot;.$object) == &quot;dir&quot;) $this-&gt;_rrmdir($dir.&quot;/&quot;.$object); else unlink($dir.&quot;/&quot;.$object);
                }
            }
            reset($objects);
            rmdir($dir);
        }
    }
}
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all();
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>