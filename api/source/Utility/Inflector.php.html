<html>
    <head>
        <script
            type="text/javascript"
            src="../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php
/**
 * CakePHP(tm) : Rapid Development Framework (http://cakephp.org)
 * Copyright (c) Cake Software Foundation, Inc. (http://cakefoundation.org)
 *
 * Licensed under The MIT License
 * For full copyright and license information, please see the LICENSE.txt
 * Redistributions of files must retain the above copyright notice.
 *
 * @copyright     Copyright (c) Cake Software Foundation, Inc. (http://cakefoundation.org)
 * @link          http://cakephp.org CakePHP(tm) Project
 * @package       Cake.Utility
 * @since         CakePHP(tm) v 0.2.9
 * @license       http://www.opensource.org/licenses/mit-license.php MIT License
 */


namespace Strata\Utility;

/**
 * Pluralize and singularize English words.
 *
 * Inflector pluralizes and singularizes English nouns.
 * Used by CakePHP's naming conventions throughout the framework.
 *
 * @package       Cake.Utility
 * @link          http://book.cakephp.org/2.0/en/core-utility-libraries/inflector.html
 */
class Inflector {

/**
 * Plural inflector rules
 *
 * @var array
 */
    protected static $_plural = array(
        'rules' =&gt; array(
            '/(s)tatus$/i' =&gt; '\1tatuses',
            '/(quiz)$/i' =&gt; '\1zes',
            '/^(ox)$/i' =&gt; '\1\2en',
            '/([m|l])ouse$/i' =&gt; '\1ice',
            '/(matr|vert|ind)(ix|ex)$/i' =&gt; '\1ices',
            '/(x|ch|ss|sh)$/i' =&gt; '\1es',
            '/([^aeiouy]|qu)y$/i' =&gt; '\1ies',
            '/(hive)$/i' =&gt; '\1s',
            '/(?:([^f])fe|([lre])f)$/i' =&gt; '\1\2ves',
            '/sis$/i' =&gt; 'ses',
            '/([ti])um$/i' =&gt; '\1a',
            '/(p)erson$/i' =&gt; '\1eople',
            '/(?&lt;!u)(m)an$/i' =&gt; '\1en',
            '/(c)hild$/i' =&gt; '\1hildren',
            '/(buffal|tomat)o$/i' =&gt; '\1\2oes',
            '/(alumn|bacill|cact|foc|fung|nucle|radi|stimul|syllab|termin|vir)us$/i' =&gt; '\1i',
            '/us$/i' =&gt; 'uses',
            '/(alias)$/i' =&gt; '\1es',
            '/(ax|cris|test)is$/i' =&gt; '\1es',
            '/s$/' =&gt; 's',
            '/^$/' =&gt; '',
            '/$/' =&gt; 's',
        ),
        'uninflected' =&gt; array(
            '.*[nrlm]ese',
            '.*data',
            '.*deer',
            '.*fish',
            '.*measles',
            '.*ois',
            '.*pox',
            '.*sheep',
            'people',
            'feedback',
            'stadia'
        ),
        'irregular' =&gt; array(
            'atlas' =&gt; 'atlases',
            'beef' =&gt; 'beefs',
            'brief' =&gt; 'briefs',
            'brother' =&gt; 'brothers',
            'cafe' =&gt; 'cafes',
            'child' =&gt; 'children',
            'cookie' =&gt; 'cookies',
            'corpus' =&gt; 'corpuses',
            'cow' =&gt; 'cows',
            'criterion' =&gt; 'criteria',
            'ganglion' =&gt; 'ganglions',
            'genie' =&gt; 'genies',
            'genus' =&gt; 'genera',
            'graffito' =&gt; 'graffiti',
            'hoof' =&gt; 'hoofs',
            'loaf' =&gt; 'loaves',
            'man' =&gt; 'men',
            'money' =&gt; 'monies',
            'mongoose' =&gt; 'mongooses',
            'move' =&gt; 'moves',
            'mythos' =&gt; 'mythoi',
            'niche' =&gt; 'niches',
            'numen' =&gt; 'numina',
            'occiput' =&gt; 'occiputs',
            'octopus' =&gt; 'octopuses',
            'opus' =&gt; 'opuses',
            'ox' =&gt; 'oxen',
            'penis' =&gt; 'penises',
            'person' =&gt; 'people',
            'sex' =&gt; 'sexes',
            'soliloquy' =&gt; 'soliloquies',
            'testis' =&gt; 'testes',
            'trilby' =&gt; 'trilbys',
            'turf' =&gt; 'turfs',
            'potato' =&gt; 'potatoes',
            'hero' =&gt; 'heroes',
            'tooth' =&gt; 'teeth',
            'goose' =&gt; 'geese',
            'foot' =&gt; 'feet',
            'sieve' =&gt; 'sieves'
        )
    );

/**
 * Singular inflector rules
 *
 * @var array
 */
    protected static $_singular = array(
        'rules' =&gt; array(
            '/(s)tatuses$/i' =&gt; '\1\2tatus',
            '/^(.*)(menu)s$/i' =&gt; '\1\2',
            '/(quiz)zes$/i' =&gt; '\\1',
            '/(matr)ices$/i' =&gt; '\1ix',
            '/(vert|ind)ices$/i' =&gt; '\1ex',
            '/^(ox)en/i' =&gt; '\1',
            '/(alias)(es)*$/i' =&gt; '\1',
            '/(alumn|bacill|cact|foc|fung|nucle|radi|stimul|syllab|termin|viri?)i$/i' =&gt; '\1us',
            '/([ftw]ax)es/i' =&gt; '\1',
            '/(cris|ax|test)es$/i' =&gt; '\1is',
            '/(shoe)s$/i' =&gt; '\1',
            '/(o)es$/i' =&gt; '\1',
            '/ouses$/' =&gt; 'ouse',
            '/([^a])uses$/' =&gt; '\1us',
            '/([m|l])ice$/i' =&gt; '\1ouse',
            '/(x|ch|ss|sh)es$/i' =&gt; '\1',
            '/(m)ovies$/i' =&gt; '\1\2ovie',
            '/(s)eries$/i' =&gt; '\1\2eries',
            '/([^aeiouy]|qu)ies$/i' =&gt; '\1y',
            '/(tive)s$/i' =&gt; '\1',
            '/(hive)s$/i' =&gt; '\1',
            '/(drive)s$/i' =&gt; '\1',
            '/([le])ves$/i' =&gt; '\1f',
            '/([^rfoa])ves$/i' =&gt; '\1fe',
            '/(^analy)ses$/i' =&gt; '\1sis',
            '/(analy|diagno|^ba|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i' =&gt; '\1\2sis',
            '/([ti])a$/i' =&gt; '\1um',
            '/(p)eople$/i' =&gt; '\1\2erson',
            '/(m)en$/i' =&gt; '\1an',
            '/(c)hildren$/i' =&gt; '\1\2hild',
            '/(n)ews$/i' =&gt; '\1\2ews',
            '/eaus$/' =&gt; 'eau',
            '/^(.*us)$/' =&gt; '\\1',
            '/s$/i' =&gt; ''
        ),
        'uninflected' =&gt; array(
            '.*data',
            '.*[nrlm]ese', '.*deer', '.*fish', '.*measles', '.*ois', '.*pox', '.*sheep', '.*ss', 'feedback'
        ),
        'irregular' =&gt; array(
            'foes' =&gt; 'foe',
        )
    );

/**
 * Words that should not be inflected
 *
 * @var array
 */
    protected static $_uninflected = array(
        'Amoyese', 'bison', 'Borghese', 'bream', 'breeches', 'britches', 'buffalo', 'cantus',
        'carp', 'chassis', 'clippers', 'cod', 'coitus', 'Congoese', 'contretemps', 'corps',
        'debris', 'diabetes', 'djinn', 'eland', 'elk', 'equipment', 'Faroese', 'flounder',
        'Foochowese', 'gallows', 'Genevese', 'Genoese', 'Gilbertese', 'graffiti',
        'headquarters', 'herpes', 'hijinks', 'Hottentotese', 'information', 'innings',
        'jackanapes', 'Kiplingese', 'Kongoese', 'Lucchese', 'mackerel', 'Maltese', '.*?media',
        'mews', 'moose', 'mumps', 'Nankingese', 'news', 'nexus', 'Niasese',
        'Pekingese', 'Piedmontese', 'pincers', 'Pistoiese', 'pliers', 'Portuguese',
        'proceedings', 'rabies', 'research', 'rice', 'rhinoceros', 'salmon', 'Sarawakese', 'scissors',
        'sea[- ]bass', 'series', 'Shavese', 'shears', 'siemens', 'species', 'swine', 'testes',
        'trousers', 'trout', 'tuna', 'Vermontese', 'Wenchowese', 'whiting', 'wildebeest',
        'Yengeese'
    );

/**
 * Default map of accented and special characters to ASCII characters
 *
 * @var array
 */
    protected static $_transliteration = array(
        '/&Agrave;|&Aacute;|&Acirc;|&Atilde;|&Aring;|Ǻ|Ā|Ă|Ą|Ǎ/' =&gt; 'A',
        '/&AElig;|Ǽ/' =&gt; 'AE',
        '/&Auml;/' =&gt; 'Ae',
        '/&Ccedil;|Ć|Ĉ|Ċ|Č/' =&gt; 'C',
        '/&ETH;|Ď|Đ/' =&gt; 'D',
        '/&Egrave;|&Eacute;|&Ecirc;|&Euml;|Ē|Ĕ|Ė|Ę|Ě/' =&gt; 'E',
        '/Ĝ|Ğ|Ġ|Ģ|Ґ/' =&gt; 'G',
        '/Ĥ|Ħ/' =&gt; 'H',
        '/&Igrave;|&Iacute;|&Icirc;|&Iuml;|Ĩ|Ī|Ĭ|Ǐ|Į|İ|І/' =&gt; 'I',
        '/Ĳ/' =&gt; 'IJ',
        '/Ĵ/' =&gt; 'J',
        '/Ķ/' =&gt; 'K',
        '/Ĺ|Ļ|Ľ|Ŀ|Ł/' =&gt; 'L',
        '/&Ntilde;|Ń|Ņ|Ň/' =&gt; 'N',
        '/&Ograve;|&Oacute;|&Ocirc;|&Otilde;|Ō|Ŏ|Ǒ|Ő|Ơ|&Oslash;|Ǿ/' =&gt; 'O',
        '/&OElig;/' =&gt; 'OE',
        '/&Ouml;/' =&gt; 'Oe',
        '/Ŕ|Ŗ|Ř/' =&gt; 'R',
        '/Ś|Ŝ|Ş|Ș|&Scaron;/' =&gt; 'S',
        '/ẞ/' =&gt; 'SS',
        '/Ţ|Ț|Ť|Ŧ/' =&gt; 'T',
        '/&THORN;/' =&gt; 'TH',
        '/&Ugrave;|&Uacute;|&Ucirc;|Ũ|Ū|Ŭ|Ů|Ű|Ų|Ư|Ǔ|Ǖ|Ǘ|Ǚ|Ǜ/' =&gt; 'U',
        '/&Uuml;/' =&gt; 'Ue',
        '/Ŵ/' =&gt; 'W',
        '/&Yacute;|&Yuml;|Ŷ/' =&gt; 'Y',
        '/Є/' =&gt; 'Ye',
        '/Ї/' =&gt; 'Yi',
        '/Ź|Ż|Ž/' =&gt; 'Z',
        '/&agrave;|&aacute;|&acirc;|&atilde;|&aring;|ǻ|ā|ă|ą|ǎ|&ordf;/' =&gt; 'a',
        '/&auml;|&aelig;|ǽ/' =&gt; 'ae',
        '/&ccedil;|ć|ĉ|ċ|č/' =&gt; 'c',
        '/&eth;|ď|đ/' =&gt; 'd',
        '/&egrave;|&eacute;|&ecirc;|&euml;|ē|ĕ|ė|ę|ě/' =&gt; 'e',
        '/&fnof;/' =&gt; 'f',
        '/ĝ|ğ|ġ|ģ|ґ/' =&gt; 'g',
        '/ĥ|ħ/' =&gt; 'h',
        '/&igrave;|&iacute;|&icirc;|&iuml;|ĩ|ī|ĭ|ǐ|į|ı|і/' =&gt; 'i',
        '/ĳ/' =&gt; 'ij',
        '/ĵ/' =&gt; 'j',
        '/ķ/' =&gt; 'k',
        '/ĺ|ļ|ľ|ŀ|ł/' =&gt; 'l',
        '/&ntilde;|ń|ņ|ň|ŉ/' =&gt; 'n',
        '/&ograve;|&oacute;|&ocirc;|&otilde;|ō|ŏ|ǒ|ő|ơ|&oslash;|ǿ|&ordm;/' =&gt; 'o',
        '/&ouml;|&oelig;/' =&gt; 'oe',
        '/ŕ|ŗ|ř/' =&gt; 'r',
        '/ś|ŝ|ş|ș|&scaron;|ſ/' =&gt; 's',
        '/&szlig;/' =&gt; 'ss',
        '/ţ|ț|ť|ŧ/' =&gt; 't',
        '/&thorn;/' =&gt; 'th',
        '/&ugrave;|&uacute;|&ucirc;|ũ|ū|ŭ|ů|ű|ų|ư|ǔ|ǖ|ǘ|ǚ|ǜ/' =&gt; 'u',
        '/&uuml;/' =&gt; 'ue',
        '/ŵ/' =&gt; 'w',
        '/&yacute;|&yuml;|ŷ/' =&gt; 'y',
        '/є/' =&gt; 'ye',
        '/ї/' =&gt; 'yi',
        '/ź|ż|ž/' =&gt; 'z',
    );

/**
 * Method cache array.
 *
 * @var array
 */
    protected static $_cache = array();

/**
 * The initial state of Inflector so reset() works.
 *
 * @var array
 */
    protected static $_initialState = array();

/**
 * Cache inflected values, and return if already available
 *
 * @param string $type Inflection type
 * @param string $key Original value
 * @param string $value Inflected value
 * @return string Inflected value, from cache
 */
    protected static function _cache($type, $key, $value = false) {
        $key = '_' . $key;
        $type = '_' . $type;
        if ($value !== false) {
            self::$_cache[$type][$key] = $value;
            return $value;
        }
        if (!isset(self::$_cache[$type][$key])) {
            return false;
        }
        return self::$_cache[$type][$key];
    }

/**
 * Clears Inflectors inflected value caches. And resets the inflection
 * rules to the initial values.
 *
 * @return void
 */
    public static function reset() {
        if (empty(self::$_initialState)) {
            self::$_initialState = get_class_vars('Inflector');
            return;
        }
        foreach (self::$_initialState as $key =&gt; $val) {
            if ($key !== '_initialState') {
                self::${$key} = $val;
            }
        }
    }

/**
 * Adds custom inflection $rules, of either 'plural', 'singular' or 'transliteration' $type.
 *
 * ### Usage:
 *
 * ```
 * Inflector::rules('plural', array('/^(inflect)or$/i' =&gt; '\1ables'));
 * Inflector::rules('plural', array(
 *     'rules' =&gt; array('/^(inflect)ors$/i' =&gt; '\1ables'),
 *     'uninflected' =&gt; array('dontinflectme'),
 *     'irregular' =&gt; array('red' =&gt; 'redlings')
 * ));
 * Inflector::rules('transliteration', array('/&aring;/' =&gt; 'aa'));
 * ```
 *
 * @param string $type The type of inflection, either 'plural', 'singular' or 'transliteration'
 * @param array $rules Array of rules to be added.
 * @param bool $reset If true, will unset default inflections for all
 *        new rules that are being defined in $rules.
 * @return void
 */
    public static function rules($type, $rules, $reset = false) {
        $var = '_' . $type;

        switch ($type) {
            case 'transliteration':
                if ($reset) {
                    self::$_transliteration = $rules;
                } else {
                    self::$_transliteration = $rules + self::$_transliteration;
                }
                break;

            default:
                foreach ($rules as $rule =&gt; $pattern) {
                    if (is_array($pattern)) {
                        if ($reset) {
                            self::${$var}[$rule] = $pattern;
                        } else {
                            if ($rule === 'uninflected') {
                                self::${$var}[$rule] = array_merge($pattern, self::${$var}[$rule]);
                            } else {
                                self::${$var}[$rule] = $pattern + self::${$var}[$rule];
                            }
                        }
                        unset($rules[$rule], self::${$var}['cache' . ucfirst($rule)]);
                        if (isset(self::${$var}['merged'][$rule])) {
                            unset(self::${$var}['merged'][$rule]);
                        }
                        if ($type === 'plural') {
                            self::$_cache['pluralize'] = self::$_cache['tableize'] = array();
                        } elseif ($type === 'singular') {
                            self::$_cache['singularize'] = array();
                        }
                    }
                }
                self::${$var}['rules'] = $rules + self::${$var}['rules'];
        }
    }

/**
 * Return $word in plural form.
 *
 * @param string $word Word in singular
 * @return string Word in plural
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/inflector.html#Inflector::pluralize
 */
    public static function pluralize($word) {
        if (isset(self::$_cache['pluralize'][$word])) {
            return self::$_cache['pluralize'][$word];
        }

        if (!isset(self::$_plural['merged']['irregular'])) {
            self::$_plural['merged']['irregular'] = self::$_plural['irregular'];
        }

        if (!isset(self::$_plural['merged']['uninflected'])) {
            self::$_plural['merged']['uninflected'] = array_merge(self::$_plural['uninflected'], self::$_uninflected);
        }

        if (!isset(self::$_plural['cacheUninflected']) || !isset(self::$_plural['cacheIrregular'])) {
            self::$_plural['cacheUninflected'] = '(?:' . implode('|', self::$_plural['merged']['uninflected']) . ')';
            self::$_plural['cacheIrregular'] = '(?:' . implode('|', array_keys(self::$_plural['merged']['irregular'])) . ')';
        }

        if (preg_match('/(.*?(?:\\b|_))(' . self::$_plural['cacheIrregular'] . ')$/i', $word, $regs)) {
            self::$_cache['pluralize'][$word] = $regs[1] .
                substr($regs[2], 0, 1) .
                substr(self::$_plural['merged']['irregular'][strtolower($regs[2])], 1);
            return self::$_cache['pluralize'][$word];
        }

        if (preg_match('/^(' . self::$_plural['cacheUninflected'] . ')$/i', $word, $regs)) {
            self::$_cache['pluralize'][$word] = $word;
            return $word;
        }

        foreach (self::$_plural['rules'] as $rule =&gt; $replacement) {
            if (preg_match($rule, $word)) {
                self::$_cache['pluralize'][$word] = preg_replace($rule, $replacement, $word);
                return self::$_cache['pluralize'][$word];
            }
        }
    }

/**
 * Return $word in singular form.
 *
 * @param string $word Word in plural
 * @return string Word in singular
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/inflector.html#Inflector::singularize
 */
    public static function singularize($word) {
        if (isset(self::$_cache['singularize'][$word])) {
            return self::$_cache['singularize'][$word];
        }

        if (!isset(self::$_singular['merged']['uninflected'])) {
            self::$_singular['merged']['uninflected'] = array_merge(
                self::$_singular['uninflected'],
                self::$_uninflected
            );
        }

        if (!isset(self::$_singular['merged']['irregular'])) {
            self::$_singular['merged']['irregular'] = array_merge(
                self::$_singular['irregular'],
                array_flip(self::$_plural['irregular'])
            );
        }

        if (!isset(self::$_singular['cacheUninflected']) || !isset(self::$_singular['cacheIrregular'])) {
            self::$_singular['cacheUninflected'] = '(?:' . implode('|', self::$_singular['merged']['uninflected']) . ')';
            self::$_singular['cacheIrregular'] = '(?:' . implode('|', array_keys(self::$_singular['merged']['irregular'])) . ')';
        }

        if (preg_match('/(.*?(?:\\b|_))(' . self::$_singular['cacheIrregular'] . ')$/i', $word, $regs)) {
            self::$_cache['singularize'][$word] = $regs[1] .
                substr($regs[2], 0, 1) .
                substr(self::$_singular['merged']['irregular'][strtolower($regs[2])], 1);
            return self::$_cache['singularize'][$word];
        }

        if (preg_match('/^(' . self::$_singular['cacheUninflected'] . ')$/i', $word, $regs)) {
            self::$_cache['singularize'][$word] = $word;
            return $word;
        }

        foreach (self::$_singular['rules'] as $rule =&gt; $replacement) {
            if (preg_match($rule, $word)) {
                self::$_cache['singularize'][$word] = preg_replace($rule, $replacement, $word);
                return self::$_cache['singularize'][$word];
            }
        }
        self::$_cache['singularize'][$word] = $word;
        return $word;
    }

/**
 * Returns the given lower_case_and_underscored_word as a CamelCased word.
 *
 * @param string $lowerCaseAndUnderscoredWord Word to camelize
 * @return string Camelized word. LikeThis.
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/inflector.html#Inflector::camelize
 */
    public static function camelize($lowerCaseAndUnderscoredWord) {
        if (!($result = self::_cache(__FUNCTION__, $lowerCaseAndUnderscoredWord))) {
            $result = str_replace(' ', '', Inflector::humanize($lowerCaseAndUnderscoredWord));
            self::_cache(__FUNCTION__, $lowerCaseAndUnderscoredWord, $result);
        }
        return $result;
    }

/**
 * Returns the given camelCasedWord as an underscored_word.
 *
 * @param string $camelCasedWord Camel-cased word to be &quot;underscorized&quot;
 * @return string Underscore-syntaxed version of the $camelCasedWord
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/inflector.html#Inflector::underscore
 */
    public static function underscore($camelCasedWord) {
        if (!($result = self::_cache(__FUNCTION__, $camelCasedWord))) {
            $underscoredWord = preg_replace('/(?&lt;=\\w)([A-Z])/', '_\\1', $camelCasedWord);
            $result = mb_strtolower($underscoredWord);
            self::_cache(__FUNCTION__, $camelCasedWord, $result);
        }
        return $result;
    }

/**
 * Returns the given underscored_word_group as a Human Readable Word Group.
 * (Underscores are replaced by spaces and capitalized following words.)
 *
 * @param string $lowerCaseAndUnderscoredWord String to be made more readable
 * @return string Human-readable string
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/inflector.html#Inflector::humanize
 */
    public static function humanize($lowerCaseAndUnderscoredWord) {
        if (!($result = self::_cache(__FUNCTION__, $lowerCaseAndUnderscoredWord))) {
            $result = explode(' ', str_replace('_', ' ', $lowerCaseAndUnderscoredWord));
            foreach ($result as &amp;$word) {
                $word = mb_strtoupper(mb_substr($word, 0, 1)) . mb_substr($word, 1);
            }
            $result = implode(' ', $result);
            self::_cache(__FUNCTION__, $lowerCaseAndUnderscoredWord, $result);
        }
        return $result;
    }

/**
 * Returns corresponding table name for given model $className. (&quot;people&quot; for the model class &quot;Person&quot;).
 *
 * @param string $className Name of class to get database table name for
 * @return string Name of the database table for given class
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/inflector.html#Inflector::tableize
 */
    public static function tableize($className) {
        if (!($result = self::_cache(__FUNCTION__, $className))) {
            $result = Inflector::pluralize(Inflector::underscore($className));
            self::_cache(__FUNCTION__, $className, $result);
        }
        return $result;
    }

/**
 * Returns Cake model class name (&quot;Person&quot; for the database table &quot;people&quot;.) for given database table.
 *
 * @param string $tableName Name of database table to get class name for
 * @return string Class name
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/inflector.html#Inflector::classify
 */
    public static function classify($tableName) {
        if (!($result = self::_cache(__FUNCTION__, $tableName))) {
            $result = Inflector::camelize(Inflector::singularize($tableName));
            self::_cache(__FUNCTION__, $tableName, $result);
        }
        return $result;
    }

/**
 * Returns camelBacked version of an underscored string.
 *
 * @param string $string String to convert.
 * @return string in variable form
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/inflector.html#Inflector::variable
 */
    public static function variable($string) {
        if (!($result = self::_cache(__FUNCTION__, $string))) {
            $camelized = Inflector::camelize(Inflector::underscore($string));
            $replace = strtolower(substr($camelized, 0, 1));
            $result = preg_replace('/\\w/', $replace, $camelized, 1);
            self::_cache(__FUNCTION__, $string, $result);
        }
        return $result;
    }

/**
 * Returns a string with all spaces converted to underscores (by default), accented
 * characters converted to non-accented characters, and non word characters removed.
 *
 * @param string $string the string you want to slug
 * @param string $replacement will replace keys in map
 * @return string
 * @link http://book.cakephp.org/2.0/en/core-utility-libraries/inflector.html#Inflector::slug
 */
    public static function slug($string, $replacement = '_') {
        $quotedReplacement = preg_quote($replacement, '/');

        $merge = array(
            '/[^\s\p{Zs}\p{Ll}\p{Lm}\p{Lo}\p{Lt}\p{Lu}\p{Nd}]/mu' =&gt; ' ',
            '/[\s\p{Zs}]+/mu' =&gt; $replacement,
            sprintf('/^[%s]+|[%s]+$/', $quotedReplacement, $quotedReplacement) =&gt; '',
        );

        $map = self::$_transliteration + $merge;
        return preg_replace(array_keys($map), array_values($map), $string);
    }

}

// Store the initial state
Inflector::reset();
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all();
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>