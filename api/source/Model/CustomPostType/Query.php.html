<html>
    <head>
        <script
            type="text/javascript"
            src="../../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php
namespace Strata\Model\CustomPostType;

use Strata\Strata;
use WP_Query;

class Query
{
    // Set defaults: return a list of published posts ordered by name
    protected $filters = array(
        'orderby'          =&gt; 'title',
        'order'            =&gt; 'ASC',
        'post_status'      =&gt; 'any',
        'nopaging'         =&gt; true,
        'suppress_filters' =&gt; true,

        // This field, though not used by Wordpress will
        // allow some flexibility with combining AND and OR query
        // relations.
        'strata_relations' =&gt; array(
            'meta_query' =&gt; array(&quot;AND&quot; =&gt; array(), &quot;OR&quot; =&gt; array()),
            'tax_query' =&gt; array(&quot;AND&quot; =&gt; array(), &quot;OR&quot; =&gt; array()),
        ),
    );

    private $executionStart = 0;

    public function __construct()
    {}

    public function fetch()
    {
        $query = $this-&gt;query();
        return $query-&gt;posts;
    }

    public function first()
    {
        $result = $this-&gt;fetch();
        return array_shift($result);
    }

    public function query()
    {
        $this-&gt;carryOverIncompatibleQueries();
        $this-&gt;relationsToQueries();
        return $this-&gt;executeFilteredQuery();
    }

    private function executeFilteredQuery()
    {
        $this-&gt;logQueryStart();
        $result = new WP_Query($this-&gt;filters);
        $this-&gt;logQueryCompletion($result-&gt;request);

        return $result;
    }

    public function listing($key, $label)
    {
        $data = array();
        foreach ($this-&gt;fetch() as $entity) {
            $data[$entity-&gt;{$key}] = $entity-&gt;{$label};
        }
        return $data;
    }

    public function date($dateQuery)
    {
        $this-&gt;filters['date_query'] = $dateQuery;
        return $this;
    }

    public function orderby($orderBy)
    {
        $this-&gt;filters['orderby'] = $orderBy;
        return $this;
    }

    public function direction($order)
    {
        $this-&gt;filters['order'] = $order;
        return $this;
    }

    public function type($type = null)
    {
        if (is_null($type)) {
            unset($this-&gt;filters['post_type']);
        } else {
            $this-&gt;filters['post_type'] = $type;
        }
        return $this;
    }

    public function status($status = null)
    {
        if (is_null($status)) {
            unset($this-&gt;filters['post_status']);
        } else {
            $this-&gt;filters['post_status'] = $status;
        }

        return $this;
    }

    public function where($field, $value)
    {
        if (strtolower($field) === &quot;meta_query&quot;) {
            return $this-&gt;metaWhere($field, $value);
        }
        elseif (strtolower($field) === &quot;tax_query&quot;) {
            return $this-&gt;taxWhere($field, $value);
        }

        $this-&gt;filters[$field] = $value;
        return $this;
    }

    public function orWhere($field, $value)
    {
        if (strtolower($field) === &quot;meta_query&quot;) {
            return $this-&gt;metaWhere($field, $value, 'OR');
        }
        elseif (strtolower($field) === &quot;tax_query&quot;) {
            return $this-&gt;taxWhere($field, $value, 'OR');
        }

        $this-&gt;filters[$field] = $value;
        return $this;
    }

    public function paginate()
    {
        $totalPages = $this-&gt;query()-&gt;max_num_pages;
        if ($totalPages &gt; 1) {
            return paginate_links(array(
                'base' =&gt; add_query_arg('paged','%#%'),
                'format' =&gt; '?paged=%#%',
                'mid-size' =&gt; 1,
                'current' =&gt; (get_query_var('paged')) ? get_query_var('paged') : 1,
                'total' =&gt; $totalPages,
                'prev_next' =&gt; true,
                'prev_text' =&gt; __('Previous', 'strata'),
                'next_text' =&gt; __('Next', 'strata')
            ));
        }

        return &quot;&quot;;
    }

    public function limit($qty)
    {
        $this-&gt;filters['posts_per_page']   = $qty;
        $this-&gt;filters['nopaging']         = false;
        return $this;
    }

    public function getFilters()
    {
        return $this-&gt;filters;
    }

    public function applyFilters($filters)
    {
        foreach($filters as $key =&gt; $value) {
            $this-&gt;filters[$key] = $value;
        }

        return $this;
    }

    // If previous meta queries are set, they may prevent the combination of
    // both 'AND' and 'OR' relation. Carries over the exclusive fields as a list of
    // IDs to apply in a Query with a new meta_query relation type.
    protected function carryOverIncompatibleQueries()
    {
        foreach($this-&gt;filters['strata_relations'] as $queryType =&gt; $queryDetails) {

            if ($this-&gt;hasRelationQuery($queryType, 'AND') &amp;&amp; $this-&gt;hasRelationQuery($queryType, 'OR')) {
                $this-&gt;andRelationToPostIn($queryType);
            }
        }

        return $this;
    }

    protected function relationsToQueries()
    {
        foreach($this-&gt;filters['strata_relations'] as $queryType =&gt; $queryDetails) {
            // At this point, there should only be exclusive AND or OR query groups
            $metaQueries = null;
            $relationTypes = array_keys($queryDetails);
            foreach ($relationTypes as $relationType)  {
                if ($this-&gt;hasRelationQuery($queryType, $relationType)) {
                    $metaQueries = $this-&gt;getRelationQuery($queryType, $relationType);
                    $this-&gt;setQueryRelation($queryType, $relationType);
                    $this-&gt;resetQueryRelation($queryType, $relationType);
                }
            }

            if (!is_null($metaQueries)) {
                foreach($metaQueries as $query) {
                    $this-&gt;addRelationQuery($queryType, $query);
                }
            }
        }

        return $this;
    }

    protected function andRelationToPostIn($query_type)
    {
        $andQuery = new Query();

        // Copy the current Query but remove the OR conditions.
        // They will be looked up as this instance goes on with
        // the process.
        $andQuery-&gt;applyFilters($this-&gt;filters);
        $andQuery-&gt;resetQueryRelation($query_type, 'OR');

        // This forces the AND relationships to be loaded before
        // comparing the or parameters
        $andIds = $andQuery-&gt;listing(&quot;ID&quot;, &quot;ID&quot;);
        $this-&gt;where('post__in', array_values($andIds));
        $this-&gt;resetQueryRelation($query_type, 'AND');

        return $this;
    }

    public function resetQueryRelation($which, $type)
    {
        $this-&gt;filters['strata_relations'][$which][$type] = array();
        return $this;
    }

    public function getRelationQuery($which, $type)
    {
        return $this-&gt;filters['strata_relations'][$which][$type];
    }

    public function hasRelationQuery($which, $type)
    {
        return count($this-&gt;getRelationQuery($which, $type)) &gt; 0;
    }

    public function setQueryRelation($type, $which)
    {
        $this-&gt;prepareRelationFilter($type);
        $this-&gt;filters[$type]['relation'] = $which;
        return $this;
    }

    public function prepareRelationFilter($type)
    {
        if (!array_key_exists($type, $this-&gt;filters) || !is_array($this-&gt;filters[$type])) {
            $this-&gt;filters[$type] = array();
        }
        return $this;
    }

    // This does not actually set the meta_query parameter. It is
    // used to build a more complex AND/OR logical fetch.
    protected function metaWhere($field, $value, $compare = 'AND')
    {
        $this-&gt;filters['strata_relations']['meta_query'][$compare][] = $value;
        return $this;
    }

    // This does not actually set the meta_query parameter. It is
    // used to build a more complex AND/OR logical fetch.
    protected function taxWhere($field, $value, $compare = 'AND')
    {
        $this-&gt;filters['strata_relations']['tax_query'][$compare][] = $value;
        return $this;
    }

    // This actually set the wp_query parameter
    private function addRelationQuery($type, $value)
    {
        $this-&gt;prepareRelationFilter($type);
        $this-&gt;filters[$type][] = $value;
        return $this;
    }

    private function logQueryStart()
    {
        $this-&gt;executionStart = microtime(true);
    }

    private function logQueryCompletion($sql)
    {
        $executionTime = microtime(true) - $this-&gt;executionStart;
        $timer = sprintf(&quot; (Done in %s seconds)&quot;, round($executionTime, 4));

        $oneLine = preg_replace('/\s+/', ' ', trim($sql));
        $app = Strata::app();
        $app-&gt;log($oneLine . $timer, &quot;[Strata:Query]&quot;);
    }

}
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all();
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>